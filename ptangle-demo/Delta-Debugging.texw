%!TEX TS-program = ./make.sh

\documentclass[a4paper,11pt,final]{article}
\usepackage{fancyvrb, color, graphicx, hyperref, amsmath, url}
\usepackage{palatino}
\usepackage{minted}
\usepackage[a4paper,text={16.5cm,25.2cm},centering]{geometry}
\usepackage{xspace}
\usepackage{pifont}    % \ding
\usepackage{amssymb}
\usepackage{amsbsy}

% Highlighting style to be used; see "pygmentize -L styles"
\usemintedstyle{xcode}

\hypersetup
{ 
  pdfauthor = {Andreas Zeller},
  pdftitle={A Demo of Delta Debugging with Pweave},
  colorlinks=TRUE,
  linkcolor=red,
  citecolor=blue,
  urlcolor=blue
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1.2ex}



\title{A Demo of Delta Debugging with Pweave}
\author{Andreas Zeller}
\date{December 18, 2017}

\begin{document}
\maketitle


\section{Introduction}

This an example of a document that can be published using
\href{http://mpastell.com/pweave}{Pweave}. Text is written
using \LaTeX{} and code between \texttt{<<>>=} and \texttt{@} is executed
and results are included in the resulting document.

You can define various options for code chunks to control code
execution and formatting (see
\href{http://mpastell.com/pweave/usage.html\#code-chunk-options}{Pweave
docs}).

\section{Delta Debugging}

We'll go and show how to implement delta debugging in Python.  

\subsection{The Testing Function}

First, you'll need a \texttt{test()} function that returns one of PASS, FAIL, or UNRESOLVED.  In our case, we will simply have it check for the presence of two parentheses.  (Syntax highlighting in PDF and HTML is automatically provided here.)

<<>>=
# A testing function
tests = 1

def test(s):
    # Simulate the program under test
    def _test(s):
        if '(' in s and ')' in s:
            return "FAIL"
        else:
            return "PASS"

    # Here's a little wrapper that will print out progress:
    t = _test(s)
    global tests
    print("Test #" + repr(tests) + " " + repr(s) + " " + repr(len(s)) + " " + t)
    tests += 1
    return t
@

\subsection{Minimizing}

Here comes the actual minimization:

<<>>=
def ddmin(s):
    # assert test("") == "PASS"
    # assert test(s) == "FAIL"

    n = 2     # Initial granularity
    while len(s) >= n:
        start = 0
        subset_length = len(s) // n   # Integer Division
        some_complement_is_failing = False

        # We keep on removing input fragments; 
        # if this succeeds, we continue with the input fragment.
        while start < len(s):
            complement = s[:start] + s[start + subset_length:]

            if test(complement) == "FAIL":
                s = complement
                n = max(n - 1, 2)
                some_complement_is_failing = True
                break
                
            start += subset_length

        # If none of our removal succeeds (i.e., the test fails), 
        # we increase the granularity.
        if not some_complement_is_failing:
            if n == len(s):
                break
            n = min(n * 2, len(s))

    # At this point, we have tried removing each single character.
    return s
@

So, what happens if we minimize an input?  (The source file only contains the code; the derived PDF and HTML files also show the execution results.)

<<>>=
if __name__ == "__main__":
    # Minimize it
    s = "1 * (2 + 3.45)"
    s_min = ddmin(s)
    print(s_min)
@


\subsection{Background}

\newcommand{\CC}{{\cal C}}
\newcommand{\RR}{{\cal R}}
\newcommand{\PASS}{{\color{green}\text{\ding{52}}}\xspace}
\newcommand{\FAIL}{{\color{red}\text{\ding{56}}}\xspace}
\newcommand{\ddmin}{\textit{ddmin}\xspace}
\newcommand{\test}{\textit{test}\xspace}
\newcommand{\cpass}{{c_{\scriptscriptstyle \PASS}}}
\newcommand{\cfail}{{c_{\scriptscriptstyle \FAIL}}}
\newcommand{\dpass}{{c'_{\scriptscriptstyle \PASS}}}
\newcommand{\dfail}{{c'_{\scriptscriptstyle \FAIL}}}
% \newcommand{\Del}[1]{{\color{blue}\Delta_{#1}}}
% \newcommand{\Nab}[1]{{\color{blue}\nabla_{\!#1}}}
\newcommand{\suchthat}[1]{\cdot #1}

Here's a formal definition of \ddmin.  This is mostly provided to test the quality of converters other than PDF\LaTeX.

\begin{align*}
  \ddmin(\cfail) &= \ddmin'(\cfail, 2) \quad \text{where} \\
  \ddmin'(\dfail, n) &= 
  \begin{cases}
    \ddmin'(\nabla_i, \max(n - 1, 2)) & \text{if $\exists i \in \{1, \dots, n\}$} \\
   & \text{$\quad \suchthat{\test(\nabla_i) = \FAIL}$} \\
    \ddmin' (\dfail, \min(2n, \left|\cfail\right|)) & \text{if $2n < \left|\cfail\right|$} \\
    \dfail & \text{otherwise}
  \end{cases} \\
&\text{with $\dfail = \Delta_1 \cup \Delta_2 \cup \dots \cup \Delta_n$,} 
\text{$\nabla_i = \dfail \setminus \Delta_i$, and} \\
&\text{$\forall \Delta_i, \Delta_j \suchthat{\Delta_i \cap \Delta_j =
    \emptyset \land |\Delta_i| \approx |\Delta_j|}$.}
\end{align*}



\end{document}
